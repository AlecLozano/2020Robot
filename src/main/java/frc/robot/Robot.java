/* Official 2642 Prayer to the FIRST Robotics Gods (the ones that remain anyway):

  We pray to Dean and Don,
 May Woodie forever rest in peace,
 to help us succeed in our matches
 and for the spirit of FIRST to fill us
 with Gracious Professionalism(TM) and Coopertition(TM).

 We pray to the Robonauts, Cheesy Poofs, Highrollers,
 Simbotics, Beach Bots, and Robowranglers
 for the power of vision tracking,
 and the ability to comprehend their code.
 We can't read too good.

 We once again pray to the previously mentioned teams,
 for the strength of our robot as a whole.
 Please don't break.

 We pray to the control systems, and National Instruments,
 for if we do not we will surely perish
 as the RoboRio may not work.
 Please have mercy.

 We pray to the Robot Inspectors and the scale,
 as even though are robot is small,
 it will probably still be too heavy.
 By the weight sensor may we succeed
 so that we may compete another day.

 We pray to the FTA
 to ensure swift connections
 and accurate cameras for the drivers.
 They need them.

 And finally to the power of stupid ideas,
 because if you spout enough nonsense,
 a good idea is bound to appear eventually.
 We love you H.A.N.G.E.R. system.

 In the name of our founder,
 and in the honor of a deceased god,
 we now say
 Kamen, and Farewell...
*/

package frc.robot;
import edu.wpi.cscore.UsbCamera;
import edu.wpi.cscore.VideoSource;
import edu.wpi.first.cameraserver.CameraServer;
import edu.wpi.first.vision.VisionThread;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.CommandScheduler;
import frc.robot.subsystems.IntakeSubsystem;;
/**
 * The VM is configured to automatically run this class, and to call the functions corresponding to
 * each mode, as described in the TimedRobot documentation. If you change the name of this class or
 * the package after creating this project, you must also update the build.gradle file in the
 * project.
 */

public class Robot<MyFindTapePipeline> extends TimedRobot {
  public Command m_autonomousCommand;
  
    // A USB camera connected to the roboRIO.
    public VideoSource usbCamera;
  public RobotContainer m_robotContainer;
  public static final IntakeSubsystem intake = new IntakeSubsystem();
  // A vision pipeline. This could be handwritten or generated by GRIP.
      // This has to implement VisionPipeline.
      // For this example, assume that it's perfect and will always see the tote.
      public MyFindTapePipeline findTapePipeline;
      public VisionThread findTapeThread;

 // The object to synchronize on to make sure the vision thread doesn't
      // write to variables the main thread is using.
      public final Object visionLock = new Object();
   /**
   * This function is run when the robot is first started up and should be used for any
   * initialization code.
   */
  // The pipeline outputs we want
  public boolean pipelineRan = false; // lets us know when the pipeline has actually run
  public double angleToTape = 0;
  public double distanceToTape = 0;
  
  public void copyPipelineOutputs(MyFindTapePipeline pipeline) {
      synchronized (visionLock) {
          // Take a snapshot of the pipeline's output because
          // it may have changed the next time this method is called!

          this.pipelineRan = true;
       //   this.angleToTape = pipeline.getAngleToTape();
      //   this.distanceToTape = pipeline.getDistanceToTape();

      }
  }
  @Override
  public void robotInit() {
    // Instantiate our RobotContainer.  This will perform all our button bindings, and put our
    // autonomous chooser on the dashboard.
    m_robotContainer = new RobotContainer();
    UsbCamera camera = CameraServer.getInstance().startAutomaticCapture();
    camera.setResolution(640, 480);
   // findTapePipeline = new FindReflectiveTape();
  //  findTapeThread = new VisionThread(usbCamera, findTapePipeline, this);
  }

  /**
   * This function is called every robot packet, no matter the mode. Use this for items like
   * diagnostics that you want ran during disabled, autonomous, teleoperated and test.
   *
   * <p>This runs after the mode specific periodic functions, but before
   * LiveWindow and SmartDashboard integrated updating.
   */
  @Override
  public void robotPeriodic() {
    // Runs the Scheduler.  This is responsible for polling buttons, adding newly-scheduled
    // commands, running already-scheduled commands, removing finished or interrupted commands,
    // and running subsystem periodic() methods.  This must be called from the robot's periodic
    // block in order for anything in the Command-based framework to work.
    CommandScheduler.getInstance().run();

    SmartDashboard.putNumber("frontLeftAngleEncoderPosition", m_robotContainer.drive.frontRightModule.getAngleEncoder());
  }

  /**
   * This function is called once each time the robot enters Disabled mode.
   */
  @Override
  public void disabledInit() {
  }

  @Override
  public void disabledPeriodic() {
  }

  /**
   * This autonomous runs the autonomous command selected by your {@link RobotContainer} class.
   */
  @Override
  public void autonomousInit() {
    m_autonomousCommand = m_robotContainer.getAutonomousCommand();

    findTapeThread.start();

    // schedule the autonomous command (example)
    if (m_autonomousCommand != null) {
      m_autonomousCommand.schedule();
    }
  }

  /**
   * This function is called periodically during autonomous.
 * @return 
   */
  double distanceToWall;
  @Override
  public void autonomousPeriodic() {
    double angleCos;
    synchronized (visionLock) {
        if (!pipelineRan) {
            // Wait until the pipeline has run
            return;
        }
        // Copy the outputs to make sure they're all from the same run
        double y = this.angleToTape;
        double x = this.distanceToTape;
        y = Math.toRadians(y);
       angleCos = Math.cos(y);
        distanceToWall = angleCos * x;
      }
    }
     //output for distanceToWall
    final double getDistanceToWall() {
      return distanceToWall;
    }


  @Override
  public void teleopInit() {
    // This makes sure that the autonomous stops running when
    // teleop starts running. If you want the autonomous to
    // continue until interrupted by another command, remove
    // this line or comment it out.
    if (m_autonomousCommand != null) {
      m_autonomousCommand.cancel();
    }
  }

  /**
   * This function is called periodically during operator control.
   */
  @Override
  public void teleopPeriodic() {
  }

  @Override
  public void testInit() {
    // Cancels all running commands at the start of test mode.
    CommandScheduler.getInstance().cancelAll();
  }

  /**
   * This function is called periodically during test mode.
   */
  @Override
  public void testPeriodic() {
  }
}
